import * as Path from 'path';
import { Plugin, ResolvedConfig } from 'vite';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as prettier from 'prettier';
import { RuntimeEnvConfig } from './runtime.env.config.js';

/**
 * Runtime environment plugin for vite
 */
export const runtimeEnv = (options: RuntimeEnvConfig = { injectHtml: true }): Plugin => {
  let envObj: Record<string, string> = {};
  let vite_config: ResolvedConfig;
  let runtimeEnvConfig: RuntimeEnvConfig;
  let vite_env_prefix: string[];

  const viteEnvs = ['MODE', 'BASE_URL', 'PROD', 'DEV', 'SSR'];

  const importMetaEnvRegex = /(import\.meta\.env)(.+)/g;
  const regexIdentifierName = /(?:[$_\p{ID_Start}])(?:[$\u200C\u200D\p{ID_Continue}])*/u;

  const isViteEnv = (name: string): boolean => {
    if (viteEnvs.includes(name)) {
      return true;
    }

    return vite_env_prefix.some(prefix => name.startsWith(prefix));
  };

  const getName = (config: RuntimeEnvConfig): string => {
    if (!config.name) {
      return 'env';
    }
    if (typeof config.name === 'string') {
      return config.name;
    }
    return config.name();
  };

  const getGeneratedTypesPath = (config: RuntimeEnvConfig): string | undefined => {
    if (!config.generatedTypesPath) {
      return undefined;
    }
    if (typeof config.generatedTypesPath === 'string') {
      return config.generatedTypesPath;
    }

    return config.generatedTypesPath();
  };

  const isNumber = (value: unknown): value is number => {
    if (typeof value === 'number') {
      return true;
    }

    if (typeof value !== 'string') return false;

    return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));
  };

  const isBoolean = (value: unknown): value is boolean => {
    if (typeof value === 'boolean') {
      return true;
    }

    if (typeof value !== 'string') {
      return false;
    }

    if (['true', '1', 'yes', 'on', 'false', '0', 'no', 'off'].includes(value.trim().toLowerCase())) return true;

    return false;
  };

  const getType = (value: unknown): string => {
    if (isNumber(value)) {
      return 'number';
    }
    if (isBoolean(value)) {
      return 'boolean';
    }

    return typeof value;
  };

  return {
    name: 'vite-plugin-runtime',
    configResolved(config) {
      vite_config = config;

      let envPrefix = vite_config.envPrefix ?? ['VITE_'];
      if (typeof envPrefix === 'string') {
        envPrefix = [envPrefix];
      }

      vite_env_prefix = envPrefix;
      runtimeEnvConfig = { ...options, ...vite_config.runtimeEnv };
    },
    buildStart() {
      const envPath = Path.resolve(vite_config.root, vite_config.envDir, '.env');
      if (fs.existsSync(envPath)) {
        envObj = { ...envObj, ...dotenv.parse(fs.readFileSync(envPath)) };
      }

      const envModePath = Path.resolve(vite_config.root, vite_config.envDir, `.env.${vite_config.mode}`);
      if (fs.existsSync(envModePath)) {
        envObj = { ...envObj, ...dotenv.parse(fs.readFileSync(envModePath)) };
      }

      const keys = Object.keys(envObj);
      keys.forEach(key => {
        if (isViteEnv(key)) {
          delete envObj[key];
        }
      });

      if (runtimeEnvConfig.generateTypes && vite_config.command === 'serve') {
        const path = getGeneratedTypesPath(runtimeEnvConfig) ?? vite_config.root;
        const name = getName(runtimeEnvConfig);
        const typePath = Path.resolve(path, `${name}.d.ts`);
        const importMetaEnvName = name === 'env' ? 'ImportMetaEnv' : 'ImportMetaRuntimeEnv';
        let output = `/** generated by vite-plugin-runtime */\ninterface ${importMetaEnvName} {`;
        Object.entries(envObj).forEach(entry => {
          output += `readonly ${entry[0]}: ${getType(entry[1])};`;
        });
        output += `} interface ImportMeta {readonly ${name}: ${importMetaEnvName};}`;

        prettier
          .format(output, {
            semi: true,
            singleQuote: true,
            arrowParens: 'avoid',
            tabWidth: 2,
            useTabs: false,
            printWidth: 100,
            parser: 'typescript',
          })
          .then(output => fs.writeFileSync(typePath, output));
      }
    },
    transform(code) {
      const globalObject = 'window';
      const globalName = getName(runtimeEnvConfig);

      for (let match = importMetaEnvRegex.exec(code); match !== null; match = importMetaEnvRegex.exec(code)) {
        const identifierMatch = regexIdentifierName.exec(match[2]);

        if (identifierMatch === null) {
          continue;
        }

        const name = identifierMatch[0];

        if (isViteEnv(name)) {
          continue;
        }

        const start = match.index;
        const end = start + match[1].length;

        code = code.slice(0, start) + `${globalObject}.${globalName}` + code.slice(end);
      }

      return code;
    },
    transformIndexHtml() {
      if (runtimeEnvConfig.injectHtml !== true) {
        return;
      }

      const globalObject = 'window';
      const globalName = getName(runtimeEnvConfig);

      let script: string | undefined;

      if (vite_config.command === 'serve') {
        script = `${globalObject}.${globalName} = {...${globalObject}.${globalName}, ...${JSON.stringify(envObj)}};`;
      } else {
        script = `import rtenv from '/${globalName}.js'; ${globalObject}.${globalName} = {...${globalObject}.${globalName}, ...rtenv};`;
      }

      return [
        {
          tag: 'script',
          attrs: {
            type: 'module',
          },
          children: script,
          injectTo: 'head-prepend',
        },
      ];
    },
    generateBundle() {
      const globalName = getName(runtimeEnvConfig);

      const jsonObj: Record<string, unknown> = {};

      Object.entries(envObj).forEach(entry => {
        const entryType = getType(entry[1]);
        jsonObj[entry[0]] = entryType === 'number' ? Number(entry[1]) : entryType === 'boolean' ? Boolean(entry[1]) : entry[1];
      });

      const output = `export default ${JSON.stringify(jsonObj)} ;`;

      this.emitFile({
        type: 'asset',
        fileName: `${globalName}.js`,
        source: output,
      });
    },
  };
};
